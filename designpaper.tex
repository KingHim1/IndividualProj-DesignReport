\documentclass[12pt,a4paper]{article}
\usepackage{times}
\usepackage{durhampaper}
\usepackage{harvard}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{forest}
\usepackage{fancybox}

\citationmode{abbr}
\bibliographystyle{agsm}

\title{SAT Solvers}
\author{King Him Cheung}
\student{King Him Cheung}
\supervisor{Dr. Friedetzky}
\degree{BSc Computer Science}

\date{}

\begin{document}

\maketitle

\begin{abstract}\newline\newline
{\bf Context/Background}\newline \\
The purpose of SAT Solvers is the solve the satisfiability problem, they are in use in modern day technologies for many practical reasons including: model checking, hardware verification, automatic test pattern generation, planning, scheduling, and even challenging problems from algebra. Over the years, we have seen new implementations of these SAT solvers which more importantly are becoming more efficient.  
\\\\
{\bf Aims}\\\\
The aim of this project is to research modern day SAT solvers and understand the reasons to their efficiency, discovering different implementations and understanding their uses is therefore vital. Furthermore, another aim of this project and one in which concrete results can be produced is the implementation of a SAT Solver capable in solving more difficult satisfiability problems.
\\\\
{\bf Method}\\\\
Various SAT solvers should be researched, comparisons in their run times should be made and recorded. Implementation on different variations of SAT Solvers ranging from their complexity, understanding the underlying concepts of these implementations, taking into consideration the algorithm and data structures involved.   
\\\\
{\bf Proposed Solution.}\\\\
Research variations of the SAT Competition solvers as a initial look into the various implementations, compare running time of these variations, taking into account search problem implementations and other solutions.\newline
Using Python to create test implementations without consideration of advanced optimisations and then moving on to produce more optimised versions either using optimised frameworks or a more low level programming language such as C++. \newline
Research modern technologies such as machine learning and how they may be used to produce more efficient solvers.



\end{abstract}

\begin{keywords}
SAT Solver, search problem, machine learning.
\end{keywords}
\newpage
\section{Introduction}

SAT Solvers come in many variations, this project is to understand the practical purpose of SAT Solvers, how SAT Solvers have developed over the years and how some variations are implemented. Concrete results can be gathered from comparing SAT solvers through their running times and use cases. Moreover, implementation of SAT Solvers of different variations including the use of more modern techniques will be made. Overall, this project will consider SAT Solvers from a theoretical view and implementations will be made from a theoretical approach on ideas from search problem and machine learning concepts.\\\\
{\bf Project Domain}\\\\
The boolean satisfiability problem is defined as: "does there exist a assignment of variables that satisfies the given boolean formula?" \\

In our consideration of this problem we will focus on Boolean Formulas in Conjunctive Normal Form: A conjunction of clause where a clause is the disjunctions of literals. 
\begin{itemize}
	\begin{item}
	A literal is a variable of the negation of the variable: x or $\neg$x.
	\end{item}
	\begin{item}
	A conjunction (X $\land$ Y) or (X$_1$ $\land$ X$_2$ $\land$ ... $ \land$ X$_n$) is True only when all variables are True.
	\end{item}
	\begin{item}
	A disjunction (X $\lor$ Y) or (X$_1$ $\lor$ X$_2$ $\lor$ ... $\lor$ X$_n$) is True only when at least one variable is True.
	\end{item}
\end{itemize}
This problem is NP-complete and many other problems can be encoded as a Satisfiability problem therefore by having efficient solvers for this problem means being able to solve many other problems. Some real world applications for SAT solvers include: Model checking, scheduling and problem solving.\\\\
Model Checking is used for hardware verification and is a technique of checking some property of the hardware by describing hardware functionality as a model: a set of states S  = $\{X_1, X_2, ..., X_n\}$ and transition relations between states  $\tau(S_1, S_2), S_1\in S$ and $S_2 \in S$. Some properties checked may include: Liveness, where a property eventually occurs e.g. used to check whether a response is eventually given or to check if cycles occur and Safety where a property always holds e.g. the reachability problem, to check whether or not a bad state can be reached. \\
Bounded model checking where a property is checked within some k steps can be solved by SAT solvers checking for satisfiability on the formula: \\
\begin{center}
$I(s_0) \land \bigwedge \limits_{i=0}^{k-1} \tau(s_i, s_i+1) \land \bigvee \limits_{i=0}^{k}\neg p(s_i)$ 
\end{center}
Where $I(s_0)$ is defined as $s_0$ being the initial state, and all states $s_i$ are iterated through by a legal transition state and none of the states reached have the property $p$.\\\\ 
\newpage
{\bf Project Overview}\\\\
The structure of this project will be focused on gaining insight in the multiple variations of SAT solvers from a theoretical view. Moreover, the projects goal of implementing of SAT solvers will allow a more in depth insight on workings of the algorithms.
\\\\
DPLL algorithm - Davis Putnam Loveland Logemann - is one such variety and one that is a basis to many modern day solvers, the algorithms involves getting as input a CNF formula and outputs whether the formula is satisfiable and if it is in fact satisfiable then it returns an assignment of variables that does so. The procedure to this algorithm follows a tree where each node of the tree is a set of clauses $S$ and at each node an assignment to a variable is made. 
\begin{center}
	\begin{tikzpicture}[level/.style={sibling distance=60mm/#1}]
		\node [circle,draw] {}
			child {node [circle,draw]  {$A$}
				child {node [circle,draw]  {$B$}
					child{ node {...}}
					child{ node {...}}
					}	
				child {node [circle,draw]  {$\neg B$}
					child{ node {...}}
					child{ node {...}}
				}
			}
			child {node [circle,draw] {$\neg A$}
				child {node [circle,draw]  {}
					child{ node {...}}
					child{ node {...}}}
				child {node [circle,draw]  {}
					child{ node {...}}
					child{ node {...}}
				}
			};
	\end{tikzpicture}
\end{center}
At each node after a variable has been assigned, we then continually apply inference (propagation) and so reducing the number of assignments and thus nodes in the tree. A node no longer has children if the node has the set \{\} as its set of clauses or if the set of clauses contain the empty set $\epsilon \in$ S. \\
If a branch has \{\} has its set of clauses then the formula is satisfiable and if all branches' set of all clauses contain the empty set $\epsilon \in$ S then the formula is unsatisfiable. \\\\
CDCL - Conflict Driven Clause Learning - is another variety of SAT solvers first used in Grasp [1] which has influenced many modern SAT Solvers, this variety of solvers is characterised by adding new clauses to its initial set of clauses as the algorithm progresses and non-chronological backtracking. As the search progresses and the branch of the search tree encounters a conflict i.e. a variable is previously set True and the most recent propagation requires the variable to be set False or vice versa. Through the conflict the algorithm learns the clause to be added to our set of clauses (clause database). The non-chronological backtracking and clause learning enables the algorithm to prune the search tree and significantly reduce the time of discovering a satisfiable assignment or to show that the formula is unsatisfiable. \\\\
There are also local search algorithms for SAT which is not complete and so may not provide an assignment of variables that satisfy the formula and may not be able to show that the formula is unsatisfiable however these algorithms can be shown to be efficient in specific cases of problems.\\
Furthermore, a more modern approach to solving SAT problems is the use of machine learning and describing the problem as a classification problem, we can classify SAT problems so that solvers more efficient on specific categories of problems can be applied, this is in contrast to the more general SAT solvers.\\\\
{\bf Project Deliverables}\\\\
{\bf Basic deliverables:}
\begin{enumerate}
		\item Implement a brute force SAT Solver using an intuitive programming language for the problem (may not be efficient)
			\begin{itemize}
				\item{- compromise on efficiency to produce a basic SAT solver using a high level language e.g. Python. Use an intuitive implementation relying on simple data structures.}
			\end{itemize}
		\item Develop understanding on a programming language that aims to increase efficiency
			\begin{itemize}
				\item{ - Read online documentation on a programming language that allows efficient use of data storage and manipulation e.g. C++, consider efficient uses of data structures and lower level data handling.}
			\end{itemize}
		\item Discover and understand optimisations made to DPLL implementations of SAT Solvers
			\begin{itemize}
				\item{-Research and develop an understanding on faster algorithms and consider the implementation of such an algorithm in the high level programming language to show proof of concept.}
			\end{itemize}
		\item Develop an understanding on machine learning
			\begin{itemize}
				\item{- Undergo an online course* on basic machine learning concepts}
			\end{itemize}	
	\end{enumerate}
{\bf Intermediate Deliverables:}
	\begin{enumerate}
		\item Research how machine learning can be applied to SAT Solving
			\begin{itemize}
				\item{- Read articles and research papers on the use of machine learning in SAT solving}
			\end{itemize}
		\item Implement a DPLL SAT Solver using an efficient programming language
			\begin{itemize}
				\item{- implement DPLL Sat Solver using the previously studied lower level programming language.}
			\end{itemize}
		\item Implement a DPLL SAT Solver involving multiple optimisations
			\begin{itemize}
				\item{- implement efficient data structures using the lower level language and implement researched optimisations to the algorithm e.g. watched literals.}
			\end{itemize}
		\item Explore and implement other versions of SAT solvers e.g. local search
	\end{enumerate}
{\bf Advanced Deliverables}
	\begin{enumerate}
		\item Analyse the efficiency benefits of the different optimisations in DPLL and its possible costs
		\item Using the knowledge of most beneficial optimisations create a SAT Solver that is as efficient as possible (with the optimisations explored)
		\item Implement a SAT Solver that utilises machine learning giving its benefits and costs
	\end{enumerate}

%overview -
% - Describe Satisfiability Problem
% - Describe problem as a solution of a search problem
% - Describe the variations of this problem

%Project Purpose - 
% - Learn theoretical concepts
% - Implement an intermediate SAT Solver
% - research modern SAT Solver variations 

% Deliverables
% Use deliverables found in Literature Review


%This section briefly introduces the project, the research question you are addressing.  Do not change the font sizes or line spacing in order to put in more text.

%Note that the whole report, including the references, should not be longer than 12 pages in length (there is no penalty for short papers if the required content is included). There should be at least 5 referenced papers.

%Programming Language
%Python (ease of programming and fast implementation) and C++ (mid level language allows for low level control and so more optimal implementation)

%Algorithms
%Pseudocode and explanation of different algorithms
%DPLL
%CDCL
%Grasp/zChaff
%Competition Examples
%Neural Nets?
%logical Regression 
%Local Search Sat Solvers

%Testing 
%Unit Testing
%Comparison of algorithms
%Run against multiple examples and check speed

\section{Design}
The design outcome of this project is to produce multiple SAT solvers that can take as input a text file of the satisfiability problem in DIMACS format [reference to http://www.satcompetition.org/2009/format-benchmarks2009.html. \\\\
\texttt{
c - this is a comment\\
c \\
c \\
p cnf 5 3\\
1 -5 4 0\\
-1 5 3 4 0\\
-3 -4 0\\
}\\
Where lines beginning with c is a comment, the line beginning with p is the format of the file e.g. the above file "p cnf 5 3" is in Conjunctive Normal Form (CNF), has 5 variables and 3 clauses. The lines below the one starting with p are the clauses of the satisfiability problem where each number denotes the variable and a minus symbol denotes the variables negation. The end of the clause is also represented by a 0.\\\\

{\bf Choice of Programming Language} \\\\
The two languages utilised in this project will be python and C++, I have used Python throughout my undergraduate studies giving me a firm familiarity with Python and therefore understanding its ease of implementation however lack of low level options resulting in less than optimal [programs]. \\
The high level nature of Python allows for fast proof of concept of algorithms allowing me test and run to different implementations quickly. This will be valuable as there are many variations of SAT solvers and a large portion of this project is to research algorithms in comparison to solely implementing them. \\
Morever, there are multiple machine learning libraries for Python and so in combination with Python's high level nature will provide a suitable level of support for testing machine learning concepts, one such example of these libraries is Pytorch a popular machine learning library and so will also result in external support such as tutorials. \\
On the other hand, C++ is a middle level language allowing for lower level control which will prove useful when producing more optimal implementations with the focus on reducing run time.\\
As we will comparing run times of implementations it will be useful to remove overheads provided from the language and so C++ is a more suitable language for this purpose. \\\\

{\bf SAT Solver Variations}\\\\
{\bf DPLL}\\
The DPLL algorithm is a backtracking search of possible assignments of variables.Our implementation of this algorithm will follow the simplest depth first search version, a recursive form that branches on a decided variable.\\
We initially run unit propagation on our input clauses and check for satisfiability or unsatisfiability. Unit propagation is the search for any unit clauses, where a unit clause is a clause that contains only one literal, after finding a unit clause we then fix the literal (i.e. a variable or its negation) found in the unit clause to True, furthermore, for every clause that contains the literal we remove from our set of clauses as well as removing negations of literals from all clauses.\\
We then check for an empty set of clause to indicate that the problem is satisfied, whereas if there is an empty set within our set of clause then the problem is unsatisfied.\\ 
(reference to graph on previous pages???)\\
After the initial check for satisfiability and unsatisfiability we then decide a variable to branch on, the function is recursively called twice on the set of clauses with the addition of either adding a unit clause of the variable in one case or a unit clause of it's negation in the other case.
\texttt{
\begin{center}Unit Propagation \end{center} 
Input Boolean Formula:\\ \hspace*{1cm} (p $\lor$ q  $\lor$ r) $\land$ ($\neg$p $\lor$ r) $\land$ (p $\lor$ s) \\
Decide:\\ \hspace*{1cm} Set literal  to true e.g. assign $\neg$p to True. \\
Update clauses:\\ \hspace*{1cm} (q $\lor$ r) $\land$ (s)\\
Find Unit Clauses:\\ \hspace*{1cm}  (q $\lor$ r) $\land$ \textbf{(s)} \\
Unit Propagation:\\ \hspace*{1cm} Set literal in unit clause to true e.g. assign s to True.
}\\\\
Resolve - Once all assignments have been propagated and there are no longer any new variables to be assigned a value we check to see if there are any conflicts. If a conflict exists we backtrack, in our basic variafhtion of our DPLL algorithm we backtrack to the last decision stage in which both values has not yet been assigned to the variable.\\\\
\texttt{
Input : A CNF formula F and an initially empty partial assignment $\rho$ \\
Output : UNSAT, or an assignment satisfying $F$\\
begin\\
\hspace*{1cm}$(F,\rho)$ $\leftarrow$ UnitPropagate $(F,\rho)$\\
\hspace*{1cm}if $F$ contains the empty clause then return UNSAT\\
\hspace*{1cm}if $F$ has no clauses left then Output $\rho$ return SAT\\
\hspace*{1cm}$l \leftarrow$ a literal not assigned by $\rho$  //the branching step \\
\hspace*{1cm}if DPLL-recursive $(F |_\ell,\rho \cup \{\ell\})$ = SAT then return SAT\\
\hspace*{1cm}return DPLL-recursive$(F |_{\neg\ell},\rho \cup \{\neg l \})$ \\
end
}
\begin{center}Pseudocode for DPLL Implementation [reference] \end{center}
The DPLL is an early SAT Solver and our implementation has many optimisations that can be added, for example we can consider: 
\begin{itemize}
	\item{More optimally deciding which variable to branch on.}
	\item{Ignoring branches that will not have a satisfying assignment.}
\end{itemize}
\hfill\\
{\bf CDCL}\\
CDCL Solvers are a variation of the DPLL algorithm and employs clause learning and other optimisations. Clause learning is the addition of learnt clauses to the original boolean formula throughout the running of the algorithm and is what distinguishes a CDCL solver to the original DPLL solvers. Our CDCL implementation will follow a repeating three stage process: Decide, Deduce and Resolve. 
\begin{enumerate}
	\item{Decide - At the decide stage of our algorithm we select a variable and assign it a value 0 or 1.}
	\item{Deduce - After the decide stage, remove all clauses with literals of which evaluates to True due to the decided variable assignment, moreover, remove all literals from clauses where that literal evaluates to false after the decided variable. Finally, we can see if we can deduce any new assignment of variables through unit propagation.}
	\item{Resolve - Once all assignments have been propagated and there are no longer any new variables to be assigned a value we check to see if there are any conflicts. If a conflict exists we backtrack to the first unique implication point (UIP), from the conflict we can also learn new clauses that can be added to our input set of clauses.}
\end{enumerate}
\texttt{CDCL$(\phi, v)$
\begin{enumerate}
\itemsep0em
\item{
if (UnitPropagation$(\phi, v)$ == CONFLICT) }
\item{
\hspace*{0.5 cm} then return UNSAT}
\item{
dl $\leftarrow$ 0}
\item{
while (not AllVariablesAssigned$(\phi, v))$}
\item{
\hspace*{0.5cm} do $(x, v)$ = PickBranchingVariable$(\phi, v)$ \bf{[decide stage]}} 
\item{
\hspace*{1cm} $dl \leftarrow dl + 1$}
\item{
\hspace*{1.5cm} $v \leftarrow v \cup \{ (x, v) \}$}
\item{
\hspace*{2cm}if (UnitPropagation$(\phi, v)$ == CONFLICT) \bf{[deduce stage]}}
\item{
\hspace*{2.5cm} return SAT}
\item{
\hspace*{3cm} then $\beta$ = ConflictAnalysis$(\phi, v)$ if $(\beta < 0)$ \bf{[resolve stage]}}
\item{
\hspace*{3.5cm} then return UNSAT }
\item{
\hspace*{3.5cm} else Backtrack$(\phi, v, \beta)$}
\item{
\hspace*{4cm} $dl \leftarrow \beta$ }
\end{enumerate}
}
\begin{center}Pseudocode for CDCL Implementation [reference] \end{center}
Definitions:\\
\begin{itemize}
\item{
Decision Level: every variable has a decision level, at each decision stage of our algorithm the decision level is incremented and the decided variable is set the new decision level, during the unit propagation stage if a variable is assigned a value then its decision level is set the same as the decision level of the most recent decided variable.}
\item{
Antecedent: Every variable has a antecedent, this is the original clause of the unit clause during unit propagation stage that caused the assignment of the variable. Variables assigned at the decide stage is set the empty clause as its antecedent.}
\end{itemize}
In this project I will focus only a few of the many optimisations for CDCL including: clause learning with UIP (unique implication points), lazy data structures with watched literals and backtracking to the first UIP.
\begin{enumerate}
\item{clause learning with UIP - Conflicts occur during the unit propagation stage, we search through the antecedents of variables of the highest decision level, those that were assigned during the most recent unit propagation, from these antecedents we add to a empty clause the literals that have a decision level value lower than the current decision level, finding such variables is achievable through resolution, this new clause will be the learnt clause and is added to our current set of clauses.\\\\
\texttt{
Resolution$(\omega1, \omega2)$: \\
Input: two clauses with one containing unique variable x and the other containing $\neg$x :\\ \hspace*{1cm} $\omega1$ = (x $\lor$ y1  $\lor$ y2 $\lor$ ...), $\omega2$ = ($\neg$x $\lor$ z1 $\lor$ z2 $\lor$ ...)\\\\
Output: clause containing all variables found in both clauses except x and $\neg$x:\\ \hspace*{2.5cm} (y1  $\lor$ y2 $\lor$ ... $\lor$ z1 $\lor$ z2 $\lor$ ...)
}

}
\item{Watched Literals - This is a lazy data structure, it's implementation is to use references to two literals of each clause in our input set of clauses, simply by referencing only two variables we do not need to scan every literal in our clause to test for a unit clause instead we update our reference to another literal if the negation of a watched literal is fixed True, at the point where there is no longer any literals left of which its variable has not been assigned then the clause is a unit clause.\\
\begin{center}
\begin{tikzpicture}
\draw (0,0) -- (1,0) -- (1,1) -- (0,1) -- (0,0) node at (0.5, 0.5){w};
\draw (1,0) -- (2,0) -- (2,1) -- (1,1) -- (1,0) node at (1.5, 0.5){w};
\draw (2,0) -- (3,0) -- (3,1) -- (2,1) -- (2,0);
\draw (3,0) -- (4,0) -- (4,1) -- (3,1) -- (3,0);
\draw (4,0) -- (5,0) -- (5,1) -- (4,1) -- (4,0);
\draw (5,0) -- (6,0) -- (6,1) -- (5,1) -- (5,0);
\end{tikzpicture}\\
\end{center}
Clause represented by array - first two literals are watched literals.\\
\begin{center}
\begin{tikzpicture}
\draw (0,0) -- (1,0) -- (1,1) -- (0,1) -- (0,0) node at (0.5, 0.5){w};
\draw [red, ultra thick](1,0) -- (2,0) -- (2,1) -- (1,1) -- (1,0) node [black] at (1.5, 0.5){w};
\draw (2,0) -- (3,0) -- (3,1) -- (2,1) -- (2,0);
\draw (3,0) -- (4,0) -- (4,1) -- (3,1) -- (3,0);
\draw (4,0) -- (5,0) -- (5,1) -- (4,1) -- (4,0);
\draw (5,0) -- (6,0) -- (6,1) -- (5,1) -- (5,0);
\end{tikzpicture}\\
\end{center}
Second literal fixed to False.
\begin{center}
\begin{tikzpicture}
\draw (0,0) -- (1,0) -- (1,1) -- (0,1) -- (0,0) node at (0.5, 0.5){w};
\draw [red, ultra thick](1,0) -- (2,0) -- (2,1) -- (1,1) -- (1,0);
\draw (2,0) -- (3,0) -- (3,1) -- (2,1) -- (2,0) node at (2.5, 0.5){w};
\draw (3,0) -- (4,0) -- (4,1) -- (3,1) -- (3,0);
\draw (4,0) -- (5,0) -- (5,1) -- (4,1) -- (4,0);
\draw (5,0) -- (6,0) -- (6,1) -- (5,1) -- (5,0);
\end{tikzpicture}\\
\end{center}
Second watched literals reference is set to another literal that has not yet been fixed.
}

\end{enumerate}

\subsection{Main Text}

The font used for the main text should be Times New Roman (Times) and the font size should be 12.  The first line of all paragraphs should be indented by 0.25in, except for the first paragraph of each section, subsection, subsubsection etc. (the paragraph immediately after the header) where no indentation is needed.

\subsection{Figures and Tables}
In general, figures and tables should not appear before they are cited.  Place figure captions below the figures; place table titles above the tables.  If your figure has two parts, for example, include the labels ``(a)'' and ``(b)'' as part of the artwork.  Please verify that figures and tables you mention in the text actually exist.  make sure that all tables and figures are numbered as shown in Table \ref{units} and Figure 1.
%sort out your own preferred means of inserting figures

\begin{table}[htb]
\centering
\caption{UNITS FOR MAGNETIC PROPERTIES}
\vspace*{6pt}
\label{units}
\begin{tabular}{ccc}\hline\hline
Symbol & Quantity & Conversion from Gaussian \\ \hline
\end{tabular}
\end{table}

\subsection{References}

The list of cited references should appear at the end of the report, ordered alphabetically by the surnames of the first authors.  The default style for references cited in the main text is the  Harvard (author, date) format.  When citing a section in a book, please give the relevant page numbers, as in \cite[p293]{budgen}.  When citing, where there are either one or two authors, use the names, but if there are more than two, give the first one and use ``et al.'' as in  , except where this would be ambiguous, in which case use all author names.

You need to give all authors' names in each reference.  Do not use ``et al.'' unless there are more than five authors.  Papers that have not been published should be cited as ``unpublished'' \cite{euther}.  Papers that have been submitted or accepted for publication should be cited as ``submitted for publication'' as in \cite{futher} .  You can also cite using just the year when the author's name appears in the text, as in ``but according to Futher \citeyear{futher}, we \dots''.  Where an authors has more than one publication in a year, add `a', `b' etc. after the year.




\bibliography{projectpaper}


\end{document}